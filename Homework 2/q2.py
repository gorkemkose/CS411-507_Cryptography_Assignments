# -*- coding: utf-8 -*-
"""q2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17pbI3cq8j_hfep05Uqoh1I91wLxaAb11
"""

import requests

API_URL = 'http://cryptlygos.pythonanywhere.com'

my_id = 25359

endpoint = '{}/{}/{}'.format(API_URL, "q2", my_id )
response = requests.get(endpoint) 	
if response.ok:	
  r = response.json()
  p, q, e, c = r['p'], r['q'], r['e'], r['cipher']    #Use these variables to calculate m

else:  
  print(response.json())

print("p:",p)
print("q:",q)
print("e:",e)
print("c:",c)

import math
import random
import fractions

# This is method to compute Euler's function
# The method here is based on "counting", which is not good for large numbers in cryptography
def phi(n):
    amount = 0
    for k in range(1, n + 1):
        if math.gcd(n, k) == 1:
            amount += 1
    return amount

# The extended Euclidean algorithm (EEA)
def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y

# Modular inverse algorithm that uses EEA
def modinv(a, m):
    if a < 0:
        a = m+a
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

n = p*q
phiOfn = (q-1) * (p-1)
d = modinv(e, phiOfn)
m = pow(c,d,n)
print("m is", m)
byteArray = m.to_bytes((m.bit_length() // 8 + 1), byteorder = 'big')
message = byteArray.decode(encoding="utf-8", errors='strict')
print(message)

m = pow(c,d,n) 	#ATTN: change this into the number you calculated and DECODE it into a string m_
m_ = message


#query result
endpoint = '{}/{}/{}/{}'.format(API_URL, "q2c", my_id, m_ )    #send your answer as a string
response = requests.put(endpoint) 	
print(response.json())