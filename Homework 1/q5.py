# -*- coding: utf-8 -*-
"""q5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mWetvSKy4pyGIKHNjj_FmEdP3I8QyYNs
"""

!apt-get install libenchant1c2a
!pip install pyenchant

import enchant
import math
import random
import fractions

d = enchant.Dict("en_US")


# The extended Euclidean algorithm (EEA)
def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y

# Modular inverse algorithm that uses EEA
def modinv(a, m):
    if a < 0:
        a = m+a
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

alphabet = {'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7, 
            'I':8, 'J':9, 'K':10, 'L':11, 'M':12, 'N':13, 'O':14, 
            'P':15, 'Q':16, 'R':17, 'S':18, 'T':19, 'U':20, 'V':21, 'W':22,
            'X':23, 'Y':24, 'Z':25, " ":26, '.':27, ',': 28, '!': 29, '?':30}

inv_alphabet = dict([(value, key) for key, value in alphabet.items()])

# This is method to compute Euler's function
# The method here is based on "counting", which is not good for large numbers in cryptography
def phi(n, alpha_beta_pairs):
  amount = 0
  for k in range(1, n + 1):
    if math.gcd(n, k) == 1:
      alpha_beta_pairs[k] = 0
      amount += 1
  return alpha_beta_pairs 

def decoder(big_number):
  triagram = ""
  last_num = big_number % 31
  big_number -= last_num
  middle_num = (big_number % (31*31)) // 31
  big_number -= middle_num
  first_num = (big_number % (31*31*31)) // (31*31)
  triagram += inv_alphabet[first_num]
  triagram += inv_alphabet[middle_num]
  triagram += inv_alphabet[last_num]
  return triagram
  

def encoder(triagram):
  encoded = 0
  for idx in range(len(triagram)):
    if idx == 0:
      encoded += 31 * 31 * alphabet[triagram[idx]]
    elif idx == 1:
      encoded += 31 * alphabet[triagram[idx]]
    else:
      encoded += alphabet[triagram[idx]]
  return encoded

def triagram_seperator(text):
  triagram_list = []
  lenght_text = len(text)
  triagram = ""
  count = 0
  for idx in range(lenght_text):
    if count < 3:
      triagram += text[idx]
      count += 1
    if count == 3:
      triagram_list.append(triagram)
      count = 0
      triagram = ""
  return triagram_list


def Affine_Dec(ctext, key):
    clen = len(ctext)
    ptext = ''
    triagram_list = triagram_seperator(ctext)
    for idx in range(0, len(triagram_list)):
      current_triagram = triagram_list[idx]
      encoded_num = encoder(current_triagram)
      encoded_plaintext_bignumber = (encoded_num * key.gamma + key.theta) % (31*31*31)
      encoded_plaintext_triagram = decoder(encoded_plaintext_bignumber)
      ptext += encoded_plaintext_triagram
    return ptext
    

class key(object):
    alpha=0
    beta=0
    gamma=0
    theta=0

#a function to determine the possible alpha and beta pairs to exhaustively search
#arguments: x which is the character in plaintext,
#           y which is the character in ciphertext
#this function only works for a known plain-ciphertext letter pair
def possible_alpha_beta_pairs(x_num, y_num, alpha_beta_pairs):
  for alpha in alpha_beta_pairs.keys():
    k = (x_num * alpha) % (31*31*31)
    beta = (y_num - k) % (31*31*31)
    alpha_beta_pairs[alpha] = beta
  return alpha_beta_pairs

#a function that splits a sentence into its words and construct a list of these words
#since the enchant library, check function works with words but not sentences, we need to have a list of words of each possible plain sentence
def list_of_words_in_sentence(sentence):
  list_of_words = []
  word = ""
  for char in sentence:
    if char.isalpha():
      word += char
    else:
      list_of_words.append(word)
      word = ""
  list_of_words.append(word)
  for i in range(0, list_of_words.count("")):
    list_of_words.remove("")
  return list_of_words

ciphertext = "IDSEOYLTVVDO?PSAUEKZO?LQIILQMP?LQNP!YSFNGSDBJZRZYTZTPS?EVYF,?LQ ,SAXSWTFXFD"

alpha_beta_pairs = {}
alpha_beta_pairs = phi(31*31*31, alpha_beta_pairs)
alpha_beta_pairs = possible_alpha_beta_pairs(encoder(".XX"), encoder("XFD"), alpha_beta_pairs)



#for each possible alpha-beta pair (total of 28830), we compute the encryption and decryption keys
#using the Affine_Dec function provided by the instructor, we decrypt the ciphertext and split the resulting sentence into its words
#in order to make a language check
#if all of its words are in english, then print the plaintext and corresponding encryption and decryption keys, else omit that one
for dictkey in alpha_beta_pairs.keys():
  key.alpha = dictkey
  key.beta = alpha_beta_pairs[dictkey]
  key.gamma = modinv(key.alpha, 31*31*31) # you can compute decryption key from encryption key
  key.theta = (31*31*31) - (key.gamma * key.beta) % (31*31*31)



  dtext = Affine_Dec(ciphertext, key)


  list_of_words = list_of_words_in_sentence(dtext)
  
  in_english = True

  for item in list_of_words:
    if not d.check(item):
      in_english = False
      break

  if in_english:
    print(dtext)
    print("Encryption key => alpha =", key.alpha, "and beta =", key.beta)
    print("Decryption key => gamma =", key.gamma, "and theta =", key.theta)