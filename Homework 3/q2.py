# -*- coding: utf-8 -*-
"""q2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RXxnSIL4eR94Y_pWuPqfMHq0Y3ZiSk-k
"""

import copy 

def LFSR(C, S):
    L = len(S)
    fb = 0
    out = S[L-1]
    for i in range(0,L):
        fb = fb^(S[i]&C[i+1])
    for i in range(L-1,0,-1):
        S[i] = S[i-1]

    S[0] = fb
    return out

def FindPeriod(s):
    n = len(s)
    for T in range(1,n+1):
        chck = 0
        for i in range(0,n-T-1):
            if (s[i] != s[i+T]):
                chck += 1
                break
        if chck == 0:
            break
    if T > n/2:
        return n
    else:
        return T        

def PolPrune(P):
    n = len(P)
    i = n-1
    while (P[i] == 0):
        del P[i]
        i = i-1
    return i

def PolDeg(P):
    n = len(P)
    i = n-1
    while (P[i] == 0):
        i = i-1
    return i

# P gets Q
def PolCopy(Q, P):
    degP = len(P)
    degQ = len(Q)
    if degP >= degQ:
        for i in range(0,degQ):
            Q[i] = P[i]
        for i in range(degQ, degP):
            Q.append(P[i])
    else: # degP < deqQ
        for i in range(0,degP):
            Q[i] = P[i]
        for i in range(degP, degQ):
            Q[i] = 0
        PolPrune(Q)           

def BM(s):
    n = len(s)

    C = []
    B = []
    T = []
    L = 0
    m = -1
    i = 0
    C.append(1)
    B.append(1)

    while(i<n):
        delta = 0
        clen = len(C)
        for j in range(0, clen):
            delta ^= (C[j]*s[i-j])
        if delta == 1:
            dif = i-m
            PolCopy(T, C)
            nlen = len(B)+dif
            if(clen >= nlen):
                for j in range(dif,nlen):
                    C[j] = C[j] ^ B[j-dif]
            else: # increase the degree of C
                for j in range(clen, nlen):
                    C.append(0)
                for j in range(dif, nlen):
                    C[j] = C[j] ^ B[j-dif]
            PolPrune(C)
            if L <= i/2:
                L = i+1-L
                m = i
                PolCopy(B, T)  
        i = i+1    
    return L, C

import math

def bitstr_to_listOfInt(bitstr):
  bin_list = []
  for i in range(len(bitstr)):
    bin_list.append(int(bitstr[i]))
  return bin_list

def generate_binary(n):
  # 2^(n-1)  2^n - 1 inclusive
  bin_arr = range(0, int(math.pow(2,n)))
  bin_arr = [bin(i)[2:] for i in bin_arr]

  # Prepending 0's to binary strings
  max_len = len(max(bin_arr, key=len))
  bin_arr = [i.zfill(max_len) for i in bin_arr]

  return bin_arr

def allInitStates(n):
  bin_arr = generate_binary(n)
  myList = []
  for eachState in bin_arr:
    state = []
    for eachBit in eachState:
      state.append(int(eachBit))
    myList.append(state)
  return myList

def matchingBits(x, z):
  count = 0
  for idx in range(len(x)):
    if x[idx] == z[idx]:
      count += 1
  return count

def reverseList(inputList):
  output = []
  for i in range(len(inputList)-1, -1,-1):
    output.append(inputList[i])
  return output

def generateKeyForAllInitials(initialList, polynomial, length, z):
  allKeys = []
  for initialState in initialList:
    keystream = [0]*length
    for i in range(0,length):
      keystream[i] = LFSR(polynomial, initialState)
    allKeys.append(keystream)

  correlatedKeys = [] #keys with coincidences of >= 70 or for this example 11
  maxCorrelatedBitNum = 0
  for key in allKeys:
    if matchingBits(key, z) >= maxCorrelatedBitNum:
      actualKey = key
      maxCorrelatedBitNum = matchingBits(key, z)

  return actualKey

def geffe(x1,x2,x3):
  return (x1 and x2) ^ (x2 and x3) ^ x3

def exhaustiveFindX2(x1, x3, z, c2):
  allInitialsForx2 = allInitStates(17)
  
  for initialState in allInitialsForx2:
    keystream = [0]*length
    for i in range(0,length):
      keystream[i] = LFSR(c2, initialState)

    flag = True
    for bitIndex in range(len(keystream)):
      x2bit = keystream[bitIndex]
      x1bit = x1[bitIndex]
      x3bit = x3[bitIndex]
      realZ = z[bitIndex]
      zbit = geffe(x1bit,x2bit,x3bit)
      if realZ != zbit:
        flag = False
        break
    if flag:
      break
  return keystream

c1 = [1,0,0,0,0,0,0,0,0,1,0,0,0,0,1]
c2 = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1]
c3 = [1,0,0,0,0,0,0,0,0,1,0,1]
z = [0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1]

length = 110
reversedZ = reverseList(z)
initialForc1 = allInitStates(14)
possibleKeyc1 = generateKeyForAllInitials(initialForc1, c1, length, reversedZ)
initialForc3 = allInitStates(11)
possibleKeyc3 = generateKeyForAllInitials(initialForc3, c3, length, reversedZ)
possibleKeyc2 = exhaustiveFindX2(possibleKeyc1, possibleKeyc3, reversedZ, c2)

k1 = reverseList(possibleKeyc1)
k2 = reverseList(possibleKeyc2)
k3 = reverseList(possibleKeyc3)

LFSR1 = reverseList(k1[:14])
LFSR2 = reverseList(k2[:17])
LFSR3 = reverseList(k3[:11])

print("Initial state for LFSR1:")
print(LFSR1, "\n")
print("Initial state for LFSR2:")
print(LFSR2, "\n")
print("Initial state for LFSR3:")
print(LFSR3, "\n")